Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение
в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.

 ----------------------------

Отношения с другими паттернами
Мост, Стратегия и Состояние (а также слегка и Адаптер) имеют схожие структуры классов — все они построены
на принципе «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем,
что решают разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом,
но и описание проблем, которые привели к данному решению.

Состояние можно рассматривать как надстройку над Стратегией. Оба паттерна используют композицию, чтобы менять
поведение основного объекта, делегируя работу вложенным объектам-помощникам. Однако в Стратегии эти объекты не
знают друг о друге и никак не связаны. В Состоянии сами конкретные состояния могут переключать контекст.

 ----------------------------

Применимость
 Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния,
 причём типов состояний много, и их код часто меняется.

 Паттерн предлагает выделить в собственные классы все поля и методы, связанные с определёнными состояниями.
 Первоначальный объект будет постоянно ссылаться на один из объектов-состояний, делегируя ему часть своей работы.
 Для изменения состояния в контекст достаточно будет подставить другой объект-состояние.

 Когда код класса содержит множество больших, похожих друг на друга, условных операторов, которые выбирают
 поведения в зависимости от текущих значений полей класса.

 Паттерн предлагает переместить каждую ветку такого условного оператора в собственный класс. Тут же можно
 поселить и все поля, связанные с данным состоянием.

 Когда вы сознательно используете табличную машину состояний, построенную на условных операторах,
 но вынуждены мириться с дублированием кода для похожих состояний и переходов.

 Паттерн Состояние позволяет реализовать иерархическую машину состояний, базирующуюся на наследовании.
 Вы можете отнаследовать похожие состояния от одного родительского класса и вынести туда весь дублирующий код.

 ----------------------------

Шаги реализации
 Определитесь с классом, который будет играть роль контекста. Это может быть как существующий класс,
 в котором уже есть зависимость от состояния, так и новый класс, если код состояний размазан по нескольким классам.

 Создайте общий интерфейс состояний. Он должен описывать методы, общие для всех состояний, обнаруженных
 в контексте. Заметьте, что не всё поведение контекста нужно переносить в состояние, а только то, которое зависит
 от состояний.

 Для каждого фактического состояния создайте класс, реализующий интерфейс состояния. Переместите код,
 связанный с конкретными состояниями в нужные классы. В конце концов, все методы интерфейса состояния должны
 быть реализованы во всех классах состояний.

 При переносе поведения из контекста вы можете столкнуться с тем, что это поведение зависит от приватных
 полей или методов контекста, к которым нет доступа из объекта состояния. Существует парочка способов обойти
 эту проблему.

 Самый простой — оставить поведение внутри контекста, вызывая его из объекта состояния.
 С другой стороны, вы можете сделать классы состояний вложенными в класс контекста, и тогда они получат
 доступ ко всем приватным частям контекста. Но последний способ доступен только в некоторых языках
 программирования (например, Java, C#).

 Создайте в контексте поле для хранения объектов-состояний, а также публичный метод для изменения значения
 этого поля.

 Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих
 методов объекта-состояния.

 В зависимости от бизнес-логики, разместите код, который переключает состояние контекста либо внутри контекста,
 либо внутри классов конкретных состояний.