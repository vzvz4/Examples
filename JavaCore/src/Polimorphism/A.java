package Polimorphism;

// Для того, чтобы функция производного класса считалась полиморфным
// вариантом функции базового класса, у них должны совпадать не только имена, но и типы аргументов.
// Поскольку A::m1 и B::m1 имеют разные типы аргументов (A и B соответственно),
// эти две функции считаются всего лишь перегрузкой имени m1 (так же как оператор + может применяться
// и к целым числам, и к числам с плавающей запятой, просто две несвязанные функции названы одинаково),
// и выбор между ними производится на этапе компиляции.
//
// Специалист сказал бы, что в Java нет ко/контравариантности по аргументам при полиморфизме.
//
// В вашем случае статический тип переменной c1 есть A, у A будет вызвана функция A::m1,
// поскольку динамический тип B, как мы выяснили, не перекрывает полиморфно эту функцию.

//В JDK 5 появилась концепция ковариантности возвращаемых типов; этот термин означает,
//что переопределенный метод производного класса может вер­нуть тип, производный от типа, возвращаемого методом базового класса.
//До JDK5, было невозможно переопределить метод если он возвращал другое значение, чем переопределяемый метод.

//Если коротко - метод считается перегруженным если в качестве аргумента принимаются различные типы,
//даже если они ковариантны/контравариантны

class A {
    void m1(B a) {
        System.out.print("A");
    }
}

class B extends A {
    void m1(C b) {
        System.out.print("B");
    }
}

class C extends B {
    void m1(C c) {
        System.out.print("C");
    }
}

class D {
    public static void main(String[] args) {
        A c1 = new C();
        c1.m1(new C());
        //output : "A"
    }
}
