package Polimorphism;

// Для того, чтобы функция производного класса считалась полиморфным
// вариантом функции базового класса, у них должны совпадать не только имена, но и типы аргументов.
// Поскольку A::m1 и B::m1 имеют разные типы аргументов (A и B соответственно),
// эти две функции считаются всего лишь перегрузкой имени m1 (так же как оператор + может применяться
// и к целым числам, и к числам с плавающей запятой, просто две несвязанные функции названы одинаково),
// и выбор между ними производится на этапе компиляции.
//
// Специалист сказал бы, что в Java нет ко/контрвариантности по аргументам при полиморфизме.
//
// В вашем случае статический тип переменной c1 есть A, у A будет вызвана функция A::m1,
// поскольку динамический тип B, как мы выяснили, не перекрывает полиморфно эту функцию.

class A {
    void m1(A a) {
        System.out.print("A");
    }
}

class B extends A {
    void m1(A b) {
        System.out.print("B");
    }
}

class C extends B {

    void m1(B c) {
        System.out.print("C");
    }
}

class D {
    public static void main(String[] args) {
        A c1 = new C();
        c1.m1(new B());
        //output : "A"
    }
}
